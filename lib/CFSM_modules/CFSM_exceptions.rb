# @author Peter Bell
# Licensed under MIT.  See License file in top level directory.

# Module to define all exceptions generated by the the CFSM class.  Broken out for readability.  Included by CFSM class.
class CFSM
  # All CFSM errors are derived from the CfsmError class to make setting up a generic handler easier.
  class CFSMError < RuntimeError; end

  # Exception class that handles the situation where an event being processed in the DelayedQueue does not have
  # an expiry.  This should never happen, since only CFSM classes are allowed to change the attributes of an event
  # once created and posted.
  class EventDoesNotHaveExpiry < CFSMError
    # @param [CFSMEvent] event The event giving rise to the error.
    def initialize(event)
      @event = event
    end
    # @return [CFSMEvent] The event giving rise to the error.
    attr_reader :event
  end

  # Exception class that handles the situation where an event has been sent to the relevant namespaces for processing
  # and then has its state set back to `:delayed`.  This should not happen.
  class AlreadySubmittedSetToDelayed < CFSMError
    # @param [CFSMEvent] event The event giving rise to the error.
    def initialize(event)
      @event = event
    end
    # @return [CFSMEvent] The event giving rise to the error.
    attr_reader :event
  end

  # This error is raised, if the options hash passed to the constructor of CFSMEvent includes an illegal key indicating
  # a likely typo.
  class CFSMEventHasIllegalOption < CFSMError
    # @param [Hash<Symbol, Object>] hash the hash contains the invalid keys.
    def initialize(hash)
      @hash = hash
    end

    # @return [Hash] the illegal key value pairings in the options list.
    attr_reader :hash

    # @return [String] the Exceptions error message
    def to_s
      "CFSMEvent has the following illegal options within the hash: #{hash.keys.to_a.to_s}"
    end
  end

  # As the individual FSM classes are derived from the CFSM class, it is possible to run the start class method on a
  # child class.  However, the system is really designed to only be run on the CFSM class.  This exception gets
  # raised if start is invoked on another class.
  class OnlyStartOnCFSMClass < CFSMError
    # @param [Class] klass the class on which the start method was incorrectly invoked
    def initialize(klass)
      @klass = klass
    end

    # @return [Class] the class on which the start method was incorrectly invoked
    attr_reader :klass

    # @return [String] the Exceptions error message.
    def to_s
      "CFSM::start has been invoked on class #{klass.to_s}. Only invoke ::start on CFSM."
    end
  end


  # If the user has derived a class from CFSM but then not instantiated any FSMs in that class, then this is probably an
  # error. Raise an error.
  class EmptyCFSMClass < CFSMError
    # @param [Class] klass the class without instantiated FSMs
    def initialize(klass)
      @klass = klass
    end

    # @return [Class] the class without instantiated FSMs
    attr_reader :klass

    # @return [String] the Exceptions error message.
    def to_s
      "CFSM::#{klass} has no instantiated FSMs."
    end
  end

  # When specifying a transition handler, the user can either do this with a block or with a reference to a method.
  # If the user has specified both, then this is an error.
  #
  # @example
  #    class Telephone < CFSM
  #     state :nothing_happening do
  #       # We are specifying two actions here.
  #       on :incoming_call, :transition => :ringing, :exec => :open_voip do |event|
  #         open_voip_connection
  #       end
  #     end
  class BlockAndExecDefined < CFSMError; end

  # Because of Ruby's dynamic nature, it is possible to re-open classes and add features to them, or to load an additional
  # file with state definitions.  So in theory would be possible to dynamically add states and event handlers.  However,
  # the RETE graph optimiser assumes everything has been defined at startup.  This exception gets raised if the system
  # detects an additional event handler being raised in a class.
  class TooLateToRegisterEvent < CFSMError; end

  # This exception indicates something has gone seriously wrong. Basically the event processor has a field in which
  # it stores what needs to happen if an event meets the conditions.  This field can either hold a Proc reference,
  # a symbol (i.e. reference to a method), or nil if the transition should occur without any further code executed.
  # This error is raised if this field contains an object other than proc, symbol, or nil.
  class CFSMErrorTransitionUnknownType < CFSMError; end


end